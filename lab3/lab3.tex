\documentclass[twoside]{article}
\usepackage[top=1in, bottom=1in, left=0.75in, right=0.75in, columnsep=20pt]{geometry}
\usepackage[framed,numbered,autolinebreaks,useliterate]{mcode}
\usepackage{listings}
\usepackage{graphicx}

\usepackage{lipsum} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

%\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{EECS C149 : Programming Embedded Systems \hfill September 18, 2014} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{Generate Tones and Program an ADC in MicroBlaze}} % Article title

\author{
\large
\textsc{Aaron Feldman, Antonio Rohit}\\[2mm] % Your name
\normalsize University of California, Berkeley \\ % Your institution
\vspace{-5mm}
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\begin{abstract}

\noindent This lab focuses on interrupts. We use the MicroBlase soft-core processor programmed on myRio to write C code to configure timers and generate tones using DIO lines. This program executes "bare-metal," or in teh absence of a scheduling kernel or operating system, and has exclusive access to the microcontroller processor, memory, and peripherals. We configured timed interrupts using memory-mapped registers on an embedded microcontroller. A timed interrupt is an interrupt that is generated by a hardware clock. For the second part of the lab, the goal is to write C code to configure a timed interrupt for periodic sampling of an analog input.

\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\begin{multicols}{2} % Two-column layout throughout the main article text

\section{Configure a Periodic Timed Interrupt:}

\noindent To generate a generate a 440Hz (fourth octave A) note, first we connected a small speaker to the DIO0 pin of the myRIO in series with a 1K$\Omega$ resistor. The purpose of the resistor was to increase the resistance of the circuit, thus lowering the current drawn from the DIO pin to one within the specs of the myRIO.\\

\begin{center}
\includegraphics*[width = 8cm]{Fig1.jpg}\\
Figure 1: myRIO Board Connected to Speaker
\end{center}

\noindent Then we used the MicroBlaze soft-core processor to configure a timer to establish a square wave of 440Hz frequency of low and high voltages on the myRIO's DIO pins. To do this, we Launched the Xilinx SDK and imported the project contained in timedIO.zip in the project files. Inside the project we modified the timedIO.c file (the full modified contents of which are attached at the end).\\

\noindent In order to override the default interrupt handler, we defined our primary interrupt handler with the interrupt\_handler attribute:

\begin{lstlisting}[frame=single]
void primary_ISR(void) __attribute__ ((interrupt_handler));
\end{lstlisting}

\noindent Now that we knew that interrupts would call our interrupt service routing (ISR), we wanted to modify the primary\_ISR function. In the primary\_ISR function we wanted to determine which interrupt fired and call the appropriate ISR. To do this we bit-wise and compared the INTC\_IPC register with masks for the timer interrupt and for the ADC interrupt.\\

\begin{lstlisting}[frame=single]
void primary_ISR(void){
	if(INTC_IPR & TIMER0_INTR_MASK) {
		timer_ISR();
	}
	if(INTC_IPR & ADC_INTR_MASK) {
			ADC_ISR();
	}
 }
\end{lstlisting}

\noindent In the timer\_ISR function, here we controlled the DIO0 pin. Setting this pin value to 1 sets the voltage output to $3.3V$ and setting the pin value to 0 sets the voltage output to $0V$. We knew that we wanted to turn the pin off and on in sequence so we chose to mod by 2 the timerIsrCount variable. The we acknowledged the interrupt so that the processor would return from the interrupt and continue.\\
\newline

\begin{lstlisting}[frame=single]
void timer_ISR(void){
	timerIsrCount++;
	DIOB_70OUT = timerIsrCount%2;
	TCSR0 = TCSR0;
 }
\end{lstlisting}

\noindent Next we had to set the timer interval and to initialize the interrupt and set the timer. To set the timer interval we knew we wanted a 440Hz signal, so we calculated a timer for 880Hz, because we knew it'd have to turn the signal on, then off, with a 50\% duty cycle. The MicroBlaze documentation specs the processor at 50MHz. A quick calculation of 50MHz/88Hz = 56818, converting into hex $\rightarrow$ DDF2, which we wrote to the Load Register TLRO. We initialized the interrupts by writing values to the Control/Status Register 0 (TCSR0). We had to experiment a bit with different values, but we found setting it to OxF6 the OxD6 worked.\\

\begin{lstlisting}[frame=single]
	TLR0 = 0xDDF2;
	TCSR0 = 0xF6;
	TCSR0 = 0xD6;
\end{lstlisting}

\noindent We found that the documentation may have been slightly wrong (or perhaps we read it wrong) on the pin-out diagram. Therefore we ended up using the oscilloscope to determine which pin was outputting the signal. This would later work in our favor for the next part. As you can see, we measured an almost perfect 440Hz on the oscilloscope.\\

\begin{center}
\includegraphics*[width = 8cm]{Fig2.jpg}\\
Figure 1: Oscilloscope of Output Frequency
\end{center}

%----------------------------------------------------------------------------------------

\section{Starve the Processor:}

Determined to find a more accurate way to determine at what frequency that the interrupts started starving the processor, and since we had previously used the oscilloscope, we decided to hook the oscilloscope back up and search for the frequency at which the output signal no longer matched the frequency we programmed. We increased to frequency to 120KHZ and had corresponding outputs that were correct. However we found that when we increased to a frequency of 135KHz and beyond the frequency no longer correlated the the frequency at which we set the timer. The image below is showing a frequency output of roughly 135KHz, but with a timer setting of 150KHz.\\

\begin{center}
\includegraphics*[width = 8cm]{Fig3.jpg}\\
Figure 1: Output Frequency no Longer Matching Settings
\end{center}

%----------------------------------------------------------------------------------------

\section{Poll the ADC:}

\noindent  To poll the ADC we modified the for loop inside main(). At first, we experienced a problem with two of the outputs reading the same value, then we realized that we forgot adding nop's in between the wrights and reads, this allowed for more than one read to grab the same value. We fixed this by adding 4 nop's in between wrights and reads. There was no explicit time settings for these reads, and the program was allowed to read the values as fast as possible.

\begin{lstlisting}[frame=single]
	for(;;){
		ADC_CTRL = 0x00000000;
		asm("nop"); asm("nop"); 
		asm("nop"); asm("nop");
		ADC_CTRL = 0x00000001;
		while (ADC_STATUS & 0x00001001);
		channel0 = (ADC_STATUS&0x0FFFFFFF)>>16;

		ADC_CTRL = 0x00010000;
		asm("nop"); asm("nop"); 
		asm("nop"); asm("nop");
		ADC_CTRL = 0x00010001;
		while (ADC_STATUS & 0x00001001);
		channel1 = (ADC_STATUS&0x0FFFFFFF)>>16;

		ADC_CTRL = 0x00020000;
		asm("nop"); asm("nop");
		asm("nop"); asm("nop");
		ADC_CTRL = 0x00020001;
		while (ADC_STATUS & 0x00002001);
		channel2 = (ADC_STATUS&0x0FFFFFFF)>>16;
	}
\end{lstlisting}

%----------------------------------------------------------------------------------------

\section{Use Timed Interrupts to Poll the ADC:}

\noindent To poll the ADC on a timer, we removed the calls to read and wright in the for loop in main(), and placed them inside the time\_ISR() function. We then set the timer for every 5 milliseconds by adjusting the value in the TLR0 register to  0x3d090 which is 250000 in decimal. In the case of using timed interrupts, we are able to free up the constant use of the CPU, but still have "busy-waiting" for the replys from the ADC.

\begin{lstlisting}[frame=single]
void timer_ISR(void){
	timerIsrCount++;
	DIOB_70OUT = timerIsrCount%2;
	
	ADC_CTRL = 0x00000000;
	asm("nop"); asm("nop");
	asm("nop"); asm("nop");
	ADC_CTRL = 0x00000001;
	while (ADC_STATUS & 0x00001001);
	channel0 = (ADC_STATUS&0x0FFFFFFF)>>16;

	ADC_CTRL = 0x00010000;
	asm("nop"); asm("nop");
	asm("nop"); asm("nop");
	ADC_CTRL = 0x00010001;
	while (ADC_STATUS & 0x00001001);
	channel1 = (ADC_STATUS&0x0FFFFFFF)>>16;

	ADC_CTRL = 0x00020000;
	asm("nop"); asm("nop");
	asm("nop"); asm("nop");
	ADC_CTRL = 0x00020001;
	while (ADC_STATUS & 0x00002001);
	channel2 = (ADC_STATUS&0x0FFFFFFF)>>16;
	
	TCSR0 = TCSR0;
 }
\end{lstlisting}

%----------------------------------------------------------------------------------------

\section{Use ADC and Timed Interrupts to Read the ADC:}

In this case we are using timed interrupts to read the ADC and interrupts to signal when the ADC has finished writing. This is the best use of the CPU of the three cases because the CPU isn't busy waiting the whole time waiting for the conversion from the ADC to finish. 

\begin{lstlisting}[frame=single]
void timer_ISR(void){
	timerIsrCount++;
	DIOB_70OUT = timerIsrCount%2;

	ADC_CTRL = 0x00000000;
	asm("nop"); asm("nop");
	asm("nop"); asm("nop");
	ADC_CTRL = 0x00000001;

	TCSR0 = TCSR0;
 }
 \end{lstlisting}
 \begin{lstlisting}[frame=single]
 void ADC_ISR(void){
	adcIsrCount++;
	switch((ADC_STATUS >> 12) & 0x03) {
		case 0:
			channel0 = (ADC_STATUS&0x0FFFFFFF)>>16;
			ADC_CTRL = 0x00010000;
			asm("nop"); asm("nop");
			asm("nop"); asm("nop");
			ADC_CTRL = 0x00010001;
			break;
		case 1:
			channel1 = (ADC_STATUS&0x0FFFFFFF)>>16;
			ADC_CTRL = 0x00020000;
			asm("nop"); asm("nop");
			asm("nop"); asm("nop");
			ADC_CTRL = 0x00020001;
			break;
		case 2:
			channel2 = (ADC_STATUS&0x0FFFFFFF)>>16;
			break;
		default:
	}
	ADC_IAR = 0x01;
}
\end{lstlisting}

\end{multicols}
\newpage
\noindent \textbf{timedIO.c}
\vspace{-5mm}
\begin{lstlisting}[frame=single]
#include <stdio.h>
#include <stdint.h>
#include "xparameters.h"
#include "mb_interface.h"

// printf() from stdlib is too big; use the Xilinx xil_printf() function instead
#define printf xil_printf

// Associate memory-mapped registers with register names used in Xilinx documentation
#define TIMER0_INTR_MASK	XPAR_TIMER0_INTERRUPT_MASK
#define ADC_INTR_MASK 		XPAR_ADC_0_ADCINT_MASK

///************************************************************************************************
//Interrupt Controller Registers
#define INTC_IPR 	(*((volatile unsigned long *)(XPAR_INTC_0_BASEADDR + 0x04)))
#define INTC_IER 	(*((volatile unsigned long *)(XPAR_INTC_0_BASEADDR + 0x08)))
#define INTC_IAR 	(*((volatile unsigned long *)(XPAR_INTC_0_BASEADDR + 0x0C)))
#define INTC_MER 	(*((volatile unsigned long *)(XPAR_INTC_0_BASEADDR + 0x1C)))

///*************************************************************************************************
///Analog to Digital Converter(ADC) Registers
#define ADC_CTRL 	(*((volatile unsigned long *)(XPAR_ADC_0_BASEADDR)))
#define ADC_STATUS 	(*((volatile unsigned long *)(XPAR_ADC_0_BASEADDR + 0x004)))
#define ADC_IAR 	(*((volatile unsigned long *)(XPAR_ADC_0_BASEADDR + 0x008)))

//***************************************************************************************************
//TIMER Registers
#define TCSR0  		(*((volatile unsigned long *)(XPAR_TIMER0_BASEADDR + 0x00)))
#define TLR0  		(*((volatile unsigned long *)(XPAR_TIMER0_BASEADDR + 0x04)))

///***************************************************************************************************
//Digital IO Registers
// DIOB_70IN   = digital inputs myRIO MXP B/DIO0-7;  bit 0 corresponds to B/DIO0 and bit 7 to B/BIO7
// DIOB_158OUT = digital output myRIO MXP B/DIO8-15; bit 0 corresponds to B/DIO8 and bit 7 to B/BIO15
#define DIOB_158IN	(*((volatile unsigned long *)(XPAR_PORTDI_BASEADDR)))
#define DIOB_70OUT	(*((volatile unsigned long *)(XPAR_PORTDO_BASEADDR)))

//Global variables for debugging purposes; incremented when interrupts fire
volatile uint32_t	primaryIsrCount = 0;
volatile uint32_t	adcIsrCount = 0;
volatile uint32_t	timerIsrCount = 0;

//Global variables to hold ADC conversion results
volatile uint32_t	channel0 = 0;
volatile uint32_t 	channel1 = 0;
volatile uint32_t	channel2 = 0;

// Function prototypes
// TODO: For interrupt exercises, signal the compiler that primary_ISR is an interrupt handler
void primary_ISR(void) __attribute__ ((interrupt_handler));
void timer_ISR(void);
void ADC_ISR(void);

// Primary ISR: call interrupt handlers for active interrupts
void primary_ISR(void){
	primaryIsrCount++;

	// TODO: Determine which interrupt fired and call appropriate ISR
	if(INTC_IPR & TIMER0_INTR_MASK)
	{
		timer_ISR();
	}
	if(INTC_IPR & ADC_INTR_MASK)
	{
			ADC_ISR();
	}

	// Acknowledge master interrupts
	INTC_IAR = INTC_IPR;
 }

// Timer ISR
void timer_ISR(void){
	timerIsrCount++;
	DIOB_70OUT = timerIsrCount%2;

	ADC_CTRL = 0x00000000;
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	ADC_CTRL = 0x00000001;
	
	// TODO: Acknowledge the timer interrupt
	// Without this acknowledgment, MicroBlaze processor will remain
	// interrupted by the Timer. The program will halt and the debugger
	// will not be able to connect until MicroBlaze is restarted.
	// If this occurs:
	//     1. Close Xilinx SDK
	//     2. Disconnect and reconnect the JTAG debugger from the computer.
	//     3. Restart SDK.
	
	TCSR0 = TCSR0;
 }

// ADC ISR: fires when ADC conversion complete
void ADC_ISR(void){
	adcIsrCount++;

	//TODO: The body of your ADC ISR lives here.
	switch((ADC_STATUS >> 12) & 0x03)
	{
		case 0:
		channel0 = (ADC_STATUS&0x0FFFFFFF)>>16;
		ADC_CTRL = 0x00010000;
		asm("nop");
		asm("nop");
		asm("nop");
		asm("nop");
		ADC_CTRL = 0x00010001;
		break;
		case 1:
		channel1 = (ADC_STATUS&0x0FFFFFFF)>>16;
		ADC_CTRL = 0x00020000;
		asm("nop");
		asm("nop");
		asm("nop");
		asm("nop");
		ADC_CTRL = 0x00020001;
		break;
		case 2:
		channel2 = (ADC_STATUS&0x0FFFFFFF)>>16;
		break;
		default:
		break;
	}

	//TODO: Acknowledge the ADC interrupt
	ADC_IAR = 0x01;
}

// Main program loop
int main(void){
	// TODO: Configure timer
	TLR0 = 0x3d090; //250000 in hex			///TODO: Load the value for timer to count down.
						//Hint : read Xilinx documentation(DS764) on AXI Timer IP  .
	TCSR0 = 0x0F6; 			///TODO: Setup timer with interrupt enable and start to count continuously
	TCSR0 = 0x0D6;

	//Hint : read Xilinx documentation(DS764) on AXI Timer IP  .
	// TODO: Enable interrupts
	INTC_IER |= TIMER0_INTR_MASK | ADC_INTR_MASK; ///TODO: Turn on correct interrupts in order to enable them.
	               //Hint : read Xilinx documentation(DS747) on AXI INTC IP  .
	INTC_MER |= 0x03; ///TODO: Enable Master and Hardware interrupt of the system.
	               //Hint : read Xilinx documentation(DS747) on AXI INTC IP  .

	// This call will allow event to interrupt MicroBlaze core
	microblaze_enable_interrupts();

	for(;;){
		// Print a debug message to the console
		printf(
			"channel0 = %05d\t"
			"channel1 = %05d\t"
			"channel2 = %05d\t"
			"primaryIsrCount = %03d\t"
			"timerIsrCount = %03d\t"
			"adcIsrCount = %03d\n",
			channel0,
			channel1,
			channel2,
			primaryIsrCount,
			timerIsrCount,
			adcIsrCount
		);
	}
    return 0;
}
\end{lstlisting}

\end{document}
